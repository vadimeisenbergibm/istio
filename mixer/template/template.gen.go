// Copyright 2017 Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOMATICALLY GENERATED.

package template

import (
	"context"
	"errors"
	"fmt"

	"github.com/gogo/protobuf/proto"
	"github.com/golang/glog"

	"istio.io/api/mixer/v1/config/descriptor"
	adptTmpl "istio.io/api/mixer/v1/template"
	"istio.io/istio/mixer/pkg/adapter"
	"istio.io/istio/mixer/pkg/attribute"
	"istio.io/istio/mixer/pkg/expr"
	"istio.io/istio/mixer/pkg/template"

	"istio.io/istio/mixer/template/apikey"

	"istio.io/istio/mixer/template/checknothing"

	"istio.io/istio/mixer/template/listentry"

	"istio.io/istio/mixer/template/logentry"

	"istio.io/istio/mixer/template/metric"

	"istio.io/istio/mixer/template/quota"

	"istio.io/istio/mixer/template/reportnothing"

	"istio.io/istio/mixer/template/tracespan"

	"time"
)

const emptyQuotes = "\"\""

var (
	SupportedTmplInfo = map[string]template.Info{

		apikey.TemplateName: {
			Name:               apikey.TemplateName,
			Impl:               "apikey",
			CtrCfg:             &apikey.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_CHECK,
			BldrInterfaceName:  apikey.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: apikey.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(apikey.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(apikey.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*apikey.InstanceParam)
				infrdType := &apikey.Type{}

				if cpb.Api == "" || cpb.Api == emptyQuotes {
					return nil, errors.New("expression for field Api cannot be empty")
				}
				if t, e := tEvalFn(cpb.Api); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field Api: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field Api: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.ApiVersion == "" || cpb.ApiVersion == emptyQuotes {
					return nil, errors.New("expression for field ApiVersion cannot be empty")
				}
				if t, e := tEvalFn(cpb.ApiVersion); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field ApiVersion: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field ApiVersion: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.ApiOperation == "" || cpb.ApiOperation == emptyQuotes {
					return nil, errors.New("expression for field ApiOperation cannot be empty")
				}
				if t, e := tEvalFn(cpb.ApiOperation); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field ApiOperation: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field ApiOperation: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.ApiKey == "" || cpb.ApiKey == emptyQuotes {
					return nil, errors.New("expression for field ApiKey cannot be empty")
				}
				if t, e := tEvalFn(cpb.ApiKey); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field ApiKey: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field ApiKey: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.Timestamp == "" || cpb.Timestamp == emptyQuotes {
					return nil, errors.New("expression for field Timestamp cannot be empty")
				}
				if t, e := tEvalFn(cpb.Timestamp); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field Timestamp: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field Timestamp: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
				}

				_ = cpb
				return infrdType, err
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(apikey.HandlerBuilder)
				castedTypes := make(map[string]*apikey.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*apikey.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetApiKeyTypes(castedTypes)
			},

			ProcessCheck: func(ctx context.Context, instName string, inst proto.Message, attrs attribute.Bag,
				mapper expr.Evaluator, handler adapter.Handler) (adapter.CheckResult, error) {
				castedInst := inst.(*apikey.InstanceParam)

				Api, err := mapper.Eval(castedInst.Api, attrs)

				if err != nil {
					msg := fmt.Sprintf("failed to eval Api for instance '%s': %v", instName, err)
					glog.Error(msg)
					return adapter.CheckResult{}, errors.New(msg)
				}

				ApiVersion, err := mapper.Eval(castedInst.ApiVersion, attrs)

				if err != nil {
					msg := fmt.Sprintf("failed to eval ApiVersion for instance '%s': %v", instName, err)
					glog.Error(msg)
					return adapter.CheckResult{}, errors.New(msg)
				}

				ApiOperation, err := mapper.Eval(castedInst.ApiOperation, attrs)

				if err != nil {
					msg := fmt.Sprintf("failed to eval ApiOperation for instance '%s': %v", instName, err)
					glog.Error(msg)
					return adapter.CheckResult{}, errors.New(msg)
				}

				ApiKey, err := mapper.Eval(castedInst.ApiKey, attrs)

				if err != nil {
					msg := fmt.Sprintf("failed to eval ApiKey for instance '%s': %v", instName, err)
					glog.Error(msg)
					return adapter.CheckResult{}, errors.New(msg)
				}

				Timestamp, err := mapper.Eval(castedInst.Timestamp, attrs)

				if err != nil {
					msg := fmt.Sprintf("failed to eval Timestamp for instance '%s': %v", instName, err)
					glog.Error(msg)
					return adapter.CheckResult{}, errors.New(msg)
				}

				_ = castedInst

				instance := &apikey.Instance{
					Name: instName,

					Api: Api.(string),

					ApiVersion: ApiVersion.(string),

					ApiOperation: ApiOperation.(string),

					ApiKey: ApiKey.(string),

					Timestamp: Timestamp.(time.Time),
				}
				return handler.(apikey.Handler).HandleApiKey(ctx, instance)
			},
		},

		checknothing.TemplateName: {
			Name:               checknothing.TemplateName,
			Impl:               "checknothing",
			CtrCfg:             &checknothing.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_CHECK,
			BldrInterfaceName:  checknothing.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: checknothing.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(checknothing.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(checknothing.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*checknothing.InstanceParam)
				infrdType := &checknothing.Type{}

				_ = cpb
				return infrdType, err
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(checknothing.HandlerBuilder)
				castedTypes := make(map[string]*checknothing.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*checknothing.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetCheckNothingTypes(castedTypes)
			},

			ProcessCheck: func(ctx context.Context, instName string, inst proto.Message, attrs attribute.Bag,
				mapper expr.Evaluator, handler adapter.Handler) (adapter.CheckResult, error) {
				castedInst := inst.(*checknothing.InstanceParam)

				_ = castedInst

				instance := &checknothing.Instance{
					Name: instName,
				}
				return handler.(checknothing.Handler).HandleCheckNothing(ctx, instance)
			},
		},

		listentry.TemplateName: {
			Name:               listentry.TemplateName,
			Impl:               "listentry",
			CtrCfg:             &listentry.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_CHECK,
			BldrInterfaceName:  listentry.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: listentry.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(listentry.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(listentry.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*listentry.InstanceParam)
				infrdType := &listentry.Type{}

				if cpb.Value == "" || cpb.Value == emptyQuotes {
					return nil, errors.New("expression for field Value cannot be empty")
				}
				if t, e := tEvalFn(cpb.Value); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field Value: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field Value: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				_ = cpb
				return infrdType, err
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(listentry.HandlerBuilder)
				castedTypes := make(map[string]*listentry.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*listentry.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetListEntryTypes(castedTypes)
			},

			ProcessCheck: func(ctx context.Context, instName string, inst proto.Message, attrs attribute.Bag,
				mapper expr.Evaluator, handler adapter.Handler) (adapter.CheckResult, error) {
				castedInst := inst.(*listentry.InstanceParam)

				Value, err := mapper.Eval(castedInst.Value, attrs)

				if err != nil {
					msg := fmt.Sprintf("failed to eval Value for instance '%s': %v", instName, err)
					glog.Error(msg)
					return adapter.CheckResult{}, errors.New(msg)
				}

				_ = castedInst

				instance := &listentry.Instance{
					Name: instName,

					Value: Value.(string),
				}
				return handler.(listentry.Handler).HandleListEntry(ctx, instance)
			},
		},

		logentry.TemplateName: {
			Name:               logentry.TemplateName,
			Impl:               "logentry",
			CtrCfg:             &logentry.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  logentry.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: logentry.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(logentry.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(logentry.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*logentry.InstanceParam)
				infrdType := &logentry.Type{}

				infrdType.Variables = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Variables))
				for k, v := range cpb.Variables {
					if infrdType.Variables[k], err = tEvalFn(v); err != nil {
						return nil, err
					}
				}

				if cpb.Timestamp == "" || cpb.Timestamp == emptyQuotes {
					return nil, errors.New("expression for field Timestamp cannot be empty")
				}
				if t, e := tEvalFn(cpb.Timestamp); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field Timestamp: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field Timestamp: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
				}

				if cpb.Severity == "" || cpb.Severity == emptyQuotes {
					return nil, errors.New("expression for field Severity cannot be empty")
				}
				if t, e := tEvalFn(cpb.Severity); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field Severity: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field Severity: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.MonitoredResourceType == "" || cpb.MonitoredResourceType == emptyQuotes {
					return nil, errors.New("expression for field MonitoredResourceType cannot be empty")
				}
				if t, e := tEvalFn(cpb.MonitoredResourceType); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field MonitoredResourceType: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field MonitoredResourceType: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				infrdType.MonitoredResourceDimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.MonitoredResourceDimensions))
				for k, v := range cpb.MonitoredResourceDimensions {
					if infrdType.MonitoredResourceDimensions[k], err = tEvalFn(v); err != nil {
						return nil, err
					}
				}

				_ = cpb
				return infrdType, err
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(logentry.HandlerBuilder)
				castedTypes := make(map[string]*logentry.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*logentry.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetLogEntryTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, insts map[string]proto.Message, attrs attribute.Bag, mapper expr.Evaluator, handler adapter.Handler) error {
				var instances []*logentry.Instance
				for name, inst := range insts {
					md := inst.(*logentry.InstanceParam)

					Variables, err := template.EvalAll(md.Variables, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Variables for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					Timestamp, err := mapper.Eval(md.Timestamp, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Timestamp for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					Severity, err := mapper.Eval(md.Severity, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Severity for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					MonitoredResourceType, err := mapper.Eval(md.MonitoredResourceType, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval MonitoredResourceType for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					MonitoredResourceDimensions, err := template.EvalAll(md.MonitoredResourceDimensions, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval MonitoredResourceDimensions for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					instances = append(instances, &logentry.Instance{
						Name: name,

						Variables: Variables,

						Timestamp: Timestamp.(time.Time),

						Severity: Severity.(string),

						MonitoredResourceType: MonitoredResourceType.(string),

						MonitoredResourceDimensions: MonitoredResourceDimensions,
					})
					_ = md
				}

				if err := handler.(logentry.Handler).HandleLogEntry(ctx, instances); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil
			},
		},

		metric.TemplateName: {
			Name:               metric.TemplateName,
			Impl:               "metric",
			CtrCfg:             &metric.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  metric.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: metric.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(metric.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(metric.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*metric.InstanceParam)
				infrdType := &metric.Type{}

				if cpb.Value == "" || cpb.Value == emptyQuotes {
					return nil, errors.New("expression for field Value cannot be empty")
				}
				if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
					return nil, err
				}

				infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
				for k, v := range cpb.Dimensions {
					if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
						return nil, err
					}
				}

				if cpb.MonitoredResourceType == "" || cpb.MonitoredResourceType == emptyQuotes {
					return nil, errors.New("expression for field MonitoredResourceType cannot be empty")
				}
				if t, e := tEvalFn(cpb.MonitoredResourceType); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field MonitoredResourceType: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field MonitoredResourceType: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				infrdType.MonitoredResourceDimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.MonitoredResourceDimensions))
				for k, v := range cpb.MonitoredResourceDimensions {
					if infrdType.MonitoredResourceDimensions[k], err = tEvalFn(v); err != nil {
						return nil, err
					}
				}

				_ = cpb
				return infrdType, err
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(metric.HandlerBuilder)
				castedTypes := make(map[string]*metric.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*metric.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetMetricTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, insts map[string]proto.Message, attrs attribute.Bag, mapper expr.Evaluator, handler adapter.Handler) error {
				var instances []*metric.Instance
				for name, inst := range insts {
					md := inst.(*metric.InstanceParam)

					Value, err := mapper.Eval(md.Value, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Value for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					Dimensions, err := template.EvalAll(md.Dimensions, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval Dimensions for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					MonitoredResourceType, err := mapper.Eval(md.MonitoredResourceType, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval MonitoredResourceType for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					MonitoredResourceDimensions, err := template.EvalAll(md.MonitoredResourceDimensions, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval MonitoredResourceDimensions for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					instances = append(instances, &metric.Instance{
						Name: name,

						Value: Value,

						Dimensions: Dimensions,

						MonitoredResourceType: MonitoredResourceType.(string),

						MonitoredResourceDimensions: MonitoredResourceDimensions,
					})
					_ = md
				}

				if err := handler.(metric.Handler).HandleMetric(ctx, instances); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil
			},
		},

		quota.TemplateName: {
			Name:               quota.TemplateName,
			Impl:               "quota",
			CtrCfg:             &quota.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_QUOTA,
			BldrInterfaceName:  quota.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: quota.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(quota.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(quota.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*quota.InstanceParam)
				infrdType := &quota.Type{}

				infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
				for k, v := range cpb.Dimensions {
					if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
						return nil, err
					}
				}

				_ = cpb
				return infrdType, err
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(quota.HandlerBuilder)
				castedTypes := make(map[string]*quota.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*quota.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetQuotaTypes(castedTypes)
			},

			ProcessQuota: func(ctx context.Context, quotaName string, inst proto.Message, attrs attribute.Bag,
				mapper expr.Evaluator, handler adapter.Handler, args adapter.QuotaArgs) (adapter.QuotaResult, error) {
				castedInst := inst.(*quota.InstanceParam)

				Dimensions, err := template.EvalAll(castedInst.Dimensions, attrs, mapper)

				if err != nil {
					msg := fmt.Sprintf("failed to eval Dimensions for instance '%s': %v", quotaName, err)
					glog.Error(msg)
					return adapter.QuotaResult{}, errors.New(msg)
				}

				instance := &quota.Instance{
					Name: quotaName,

					Dimensions: Dimensions,
				}

				return handler.(quota.Handler).HandleQuota(ctx, instance, args)
			},
		},

		reportnothing.TemplateName: {
			Name:               reportnothing.TemplateName,
			Impl:               "reportnothing",
			CtrCfg:             &reportnothing.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  reportnothing.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: reportnothing.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(reportnothing.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(reportnothing.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*reportnothing.InstanceParam)
				infrdType := &reportnothing.Type{}

				_ = cpb
				return infrdType, err
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(reportnothing.HandlerBuilder)
				castedTypes := make(map[string]*reportnothing.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*reportnothing.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetReportNothingTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, insts map[string]proto.Message, attrs attribute.Bag, mapper expr.Evaluator, handler adapter.Handler) error {
				var instances []*reportnothing.Instance
				for name, inst := range insts {
					md := inst.(*reportnothing.InstanceParam)

					instances = append(instances, &reportnothing.Instance{
						Name: name,
					})
					_ = md
				}

				if err := handler.(reportnothing.Handler).HandleReportNothing(ctx, instances); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil
			},
		},

		tracespan.TemplateName: {
			Name:               tracespan.TemplateName,
			Impl:               "tracespan",
			CtrCfg:             &tracespan.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  tracespan.TemplateName + "." + "HandlerBuilder",
			HndlrInterfaceName: tracespan.TemplateName + "." + "Handler",
			BuilderSupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(tracespan.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(tracespan.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*tracespan.InstanceParam)
				infrdType := &tracespan.Type{}

				if cpb.TraceId == "" || cpb.TraceId == emptyQuotes {
					return nil, errors.New("expression for field TraceId cannot be empty")
				}
				if t, e := tEvalFn(cpb.TraceId); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field TraceId: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field TraceId: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.SpanId == "" || cpb.SpanId == emptyQuotes {
					return nil, errors.New("expression for field SpanId cannot be empty")
				}
				if t, e := tEvalFn(cpb.SpanId); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field SpanId: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field SpanId: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.ParentSpanId == "" || cpb.ParentSpanId == emptyQuotes {
					return nil, errors.New("expression for field ParentSpanId cannot be empty")
				}
				if t, e := tEvalFn(cpb.ParentSpanId); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field ParentSpanId: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field ParentSpanId: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.SpanName == "" || cpb.SpanName == emptyQuotes {
					return nil, errors.New("expression for field SpanName cannot be empty")
				}
				if t, e := tEvalFn(cpb.SpanName); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field SpanName: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field SpanName: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.StartTime == "" || cpb.StartTime == emptyQuotes {
					return nil, errors.New("expression for field StartTime cannot be empty")
				}
				if t, e := tEvalFn(cpb.StartTime); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field StartTime: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field StartTime: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
				}

				if cpb.EndTime == "" || cpb.EndTime == emptyQuotes {
					return nil, errors.New("expression for field EndTime cannot be empty")
				}
				if t, e := tEvalFn(cpb.EndTime); e != nil || t != istio_mixer_v1_config_descriptor.TIMESTAMP {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field EndTime: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field EndTime: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.TIMESTAMP)
				}

				infrdType.SpanTags = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.SpanTags))
				for k, v := range cpb.SpanTags {
					if infrdType.SpanTags[k], err = tEvalFn(v); err != nil {
						return nil, err
					}
				}

				_ = cpb
				return infrdType, err
			},
			SetType: func(types map[string]proto.Message, builder adapter.HandlerBuilder) {
				// Mixer framework should have ensured the type safety.
				castedBuilder := builder.(tracespan.HandlerBuilder)
				castedTypes := make(map[string]*tracespan.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*tracespan.Type)
					castedTypes[k] = v1
				}
				castedBuilder.SetTraceSpanTypes(castedTypes)
			},

			ProcessReport: func(ctx context.Context, insts map[string]proto.Message, attrs attribute.Bag, mapper expr.Evaluator, handler adapter.Handler) error {
				var instances []*tracespan.Instance
				for name, inst := range insts {
					md := inst.(*tracespan.InstanceParam)

					TraceId, err := mapper.Eval(md.TraceId, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval TraceId for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					SpanId, err := mapper.Eval(md.SpanId, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval SpanId for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					ParentSpanId, err := mapper.Eval(md.ParentSpanId, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval ParentSpanId for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					SpanName, err := mapper.Eval(md.SpanName, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval SpanName for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					StartTime, err := mapper.Eval(md.StartTime, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval StartTime for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					EndTime, err := mapper.Eval(md.EndTime, attrs)

					if err != nil {
						msg := fmt.Sprintf("failed to eval EndTime for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					SpanTags, err := template.EvalAll(md.SpanTags, attrs, mapper)

					if err != nil {
						msg := fmt.Sprintf("failed to eval SpanTags for instance '%s': %v", name, err)
						glog.Error(msg)
						return errors.New(msg)
					}

					instances = append(instances, &tracespan.Instance{
						Name: name,

						TraceId: TraceId.(string),

						SpanId: SpanId.(string),

						ParentSpanId: ParentSpanId.(string),

						SpanName: SpanName.(string),

						StartTime: StartTime.(time.Time),

						EndTime: EndTime.(time.Time),

						SpanTags: SpanTags,
					})
					_ = md
				}

				if err := handler.(tracespan.Handler).HandleTraceSpan(ctx, instances); err != nil {
					return fmt.Errorf("failed to report all values: %v", err)
				}
				return nil
			},
		},
	}
)
